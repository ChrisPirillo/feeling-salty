<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Feeling Salty - Procedural SEM Crystal Simulator</title>
    
    <!-- SEO & Metadata -->
    <meta name="description" content="Explore 'Feeling Salty', a high-fidelity procedural cubic crystallization simulator. Generate realistic Scanning Electron Microscopy (SEM) visuals of salt-like structures with adjustable lighting, textures, and geometry.">
    <meta name="keywords" content="procedural generation, three.js, webgl, crystallography, scanning electron microscope, SEM simulator, digital art, salt crystals, generative art, 3D visualization">
    <meta name="author" content="Chris Pirillo (@ChrisPirillo)">
    <link rel="canonical" href="https://pirillo.com/arcade/feeling-salty.html">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:title" content="Feeling Salty - Procedural SEM Crystal Simulator">
    <meta property="og:description" content="A real-time WebGL simulation of cubic crystallization mimicking Scanning Electron Microscopy imaging.">
    <meta property="og:url" content="https://pirillo.com/arcade/feeling-salty.html">
    <meta property="og:image" content="https://pirillo.com/arcade/images/feeling-salty.png">
    <meta property="og:site_name" content="Pirillo Arcade">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@ChrisPirillo">
    <meta name="twitter:creator" content="@ChrisPirillo">
    <meta name="twitter:title" content="Feeling Salty">
    <meta name="twitter:description" content="Procedural SEM-style crystal generation in your browser.">
    <meta name="twitter:image" content="https://pirillo.com/arcade/images/feeling-salty.png">

    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Feeling Salty",
      "url": "https://pirillo.com/arcade/feeling-salty.html",
      "description": "A procedural cubic crystallization simulator that mimics Scanning Electron Microscopy (SEM) imaging.",
      "author": {
        "@type": "Person",
        "name": "Chris Pirillo",
        "url": "https://chris.pirillo.com"
      },
      "applicationCategory": "Simulation",
      "operatingSystem": "Any"
    }
    </script>

    <!-- Google Tag Manager -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-1CQ4D3VQ3L"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-1CQ4D3VQ3L');
    </script>

    <!-- Performance Hints -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" as="script">
    
    <!-- Styles -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        :root {
            --bg: #050505;
            --panel-bg: rgba(12, 12, 12, 0.95);
            --panel-border: rgba(255, 255, 255, 0.12);
            --accent: #fff;
            --text-main: #eee;
            --text-dim: #888;
            --slider-track: rgba(255, 255, 255, 0.15);
            --font-ui: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0; overflow: hidden; background: var(--bg);
            font-family: var(--font-ui); color: var(--text-main);
            user-select: none;
        }

        /* CANVAS & FX */
        #canvas-container { position: absolute; inset: 0; z-index: 1; }
        #vignette {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            background: radial-gradient(circle at center, transparent 30%, #000 140%);
            opacity: 0.6;
        }
        #fade-overlay {
            position: absolute; inset: 0; background: #000;
            opacity: 1; pointer-events: none; z-index: 20;
            transition: opacity 0.6s cubic-bezier(0.2, 0, 0.2, 1);
        }

        /* UI CONTAINER */
        #ui-layer {
            position: absolute; top: 20px; right: 20px; bottom: 20px;
            width: 340px; z-index: 100;
            display: flex; flex-direction: column;
            pointer-events: none;
        }

        #controls-panel {
            pointer-events: auto;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--panel-border);
            border-radius: 8px;
            display: flex; flex-direction: column;
            height: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            transform: translateX(0);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        
        #controls-panel.collapsed { transform: translateX(calc(100% + 40px)); }

        /* HEADER */
        .panel-header {
            padding: 16px 20px;
            border-bottom: 1px solid var(--panel-border);
            display: flex; justify-content: space-between; align-items: center;
            flex-shrink: 0;
        }
        .app-title {
            font-family: var(--font-mono); font-weight: 700; font-size: 14px;
            letter-spacing: -0.02em; text-transform: uppercase;
        }
        .header-tools { display: flex; gap: 12px; align-items: center; }
        
        .icon-btn {
            background: none; border: none; color: var(--text-dim);
            cursor: pointer; padding: 4px; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center;
        }
        .icon-btn:hover { color: var(--accent); }

        /* Encircled Info Button */
        #btn-info {
            width: 20px; height: 20px; 
            border: 1px solid var(--text-dim); border-radius: 50%;
            font-size: 11px; font-weight: 700; padding: 0;
            color: var(--text-dim);
        }
        #btn-info:hover { border-color: var(--accent); color: var(--accent); background: rgba(255,255,255,0.1); }

        /* SCROLLABLE CONTENT */
        .panel-content {
            flex: 1; overflow-y: auto; padding: 10px;
            scrollbar-width: thin; scrollbar-color: #444 transparent;
        }
        .panel-content::-webkit-scrollbar { width: 4px; }
        .panel-content::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }

        /* SECTIONS */
        .control-group { margin-bottom: 8px; border: 1px solid var(--panel-border); border-radius: 6px; background: rgba(0,0,0,0.2); overflow: hidden; }
        .control-group summary {
            padding: 12px 16px; cursor: pointer; list-style: none;
            display: flex; justify-content: space-between; align-items: center;
            font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em;
            color: var(--text-dim); background: rgba(255,255,255,0.02);
            transition: background 0.2s, color 0.2s;
        }
        .control-group summary:hover { color: var(--accent); background: rgba(255,255,255,0.05); }
        .control-group[open] summary { border-bottom: 1px solid var(--panel-border); color: var(--accent); }
        .control-group summary::after { content: '+'; font-family: var(--font-mono); font-size: 14px; font-weight: 400; opacity: 0.5; }
        .control-group[open] summary::after { content: '−'; }
        
        .group-body { padding: 16px; display: flex; flex-direction: column; gap: 18px; }

        /* CONTROLS */
        .ctrl-row { display: flex; flex-direction: column; gap: 8px; }
        .ctrl-header { display: flex; justify-content: space-between; align-items: baseline; }
        .ctrl-label { font-size: 11px; color: #aaa; font-weight: 500; }
        .ctrl-val {
            font-family: var(--font-mono); font-size: 10px;
            background: rgba(255,255,255,0.1); padding: 2px 6px;
            border-radius: 3px; min-width: 36px; text-align: center;
            color: var(--accent);
        }

        /* SLIDER */
        input[type="range"] {
            -webkit-appearance: none; width: 100%; height: 20px;
            background: transparent; cursor: pointer; display: block; margin: 0;
        }
        input[type="range"]:focus { outline: none; }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: var(--slider-track); border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 2px; background: var(--accent); margin-top: -6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.5); border: 1px solid rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        input[type="range"]:active::-webkit-slider-thumb { transform: scale(1.2); }

        /* COLOR PICKER */
        .color-row { display: flex; align-items: center; justify-content: space-between; }
        .color-wrap {
            width: 100%; height: 28px; border-radius: 4px;
            border: 1px solid var(--panel-border); overflow: hidden; position: relative;
        }
        input[type="color"] {
            position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            cursor: pointer; border: none; padding: 0; margin: 0;
        }

        /* DROPDOWN SELECT */
        select {
            width: 100%; background: rgba(0,0,0,0.3); color: var(--text-main);
            border: 1px solid var(--panel-border); border-radius: 4px;
            padding: 6px 10px; font-family: var(--font-ui); font-size: 11px;
            outline: none; cursor: pointer;
        }
        select:hover { border-color: rgba(255,255,255,0.3); }
        select option { background: #111; color: #fff; padding: 10px; }

        /* FOOTER ACTIONS */
        .panel-footer {
            padding: 16px; border-top: 1px solid var(--panel-border);
            display: flex; flex-direction: column; gap: 8px;
        }

        .btn-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        .btn {
            background: rgba(255,255,255,0.05); border: 1px solid var(--panel-border);
            color: var(--text-main); font-family: var(--font-mono); font-size: 11px;
            text-transform: uppercase; padding: 12px 0; cursor: pointer;
            border-radius: 4px; transition: all 0.2s; text-align: center; white-space: nowrap;
        }
        .btn:hover { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.4); color: #fff; }
        
        .btn-primary { 
            background: var(--text-main); color: #000; font-weight: 700; border: none; 
            margin-bottom: 4px;
        }
        .btn-primary:hover { background: #fff; transform: translateY(-1px); }

        /* TOGGLE BUTTON */
        #toggle-hud {
            position: absolute; top: 20px; right: 20px; width: 44px; height: 44px;
            background: #111; border: 1px solid var(--panel-border); color: #fff;
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; pointer-events: auto; opacity: 0; transition: opacity 0.3s;
            z-index: 90;
        }
        #toggle-hud.visible { opacity: 1; }

        /* INFO MODAL */
        #modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px); z-index: 200;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #modal.visible { opacity: 1; pointer-events: auto; }
        .modal-card {
            background: #111; border: 1px solid #333; padding: 40px;
            width: 100%; max-width: 400px; text-align: center; border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
        }
        .modal-title { font-family: var(--font-mono); margin: 0 0 10px 0; color: #fff; letter-spacing: 2px; font-size: 16px; }
        .modal-text { color: #888; font-size: 13px; line-height: 1.6; margin-bottom: 25px; }
        
        .modal-links {
            display: flex; flex-direction: column; gap: 8px; margin-bottom: 25px;
        }
        .modal-link {
            display: block; padding: 12px; background: rgba(255,255,255,0.05);
            border: 1px solid #333; border-radius: 4px;
            color: #ccc; text-decoration: none; font-family: var(--font-mono); font-size: 12px;
            text-transform: uppercase; transition: all 0.2s;
        }
        .modal-link:hover { background: #eee; color: #000; border-color: #eee; }
        
        .modal-hint { font-size: 11px; opacity: 0.5; font-family: var(--font-mono); }
    </style>
</head>
<body>

    <main id="canvas-container"></main>
    <div id="vignette"></div>
    <div id="fade-overlay"></div>

    <button id="toggle-hud" class="visible" aria-label="Show Controls">
        <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
    </button>

    <aside id="ui-layer">
        <section id="controls-panel" class="collapsed">
            <header class="panel-header">
                <h1 class="app-title">Feeling Salty <span style="color:var(--text-dim); font-size:10px;">v3.8</span></h1>
                <div class="header-tools">
                    <button class="icon-btn" id="btn-info" title="About" aria-label="About">?</button>
                    <button class="icon-btn" id="btn-close" title="Hide Controls" aria-label="Hide Controls">✕</button>
                </div>
            </header>

            <div class="panel-content" id="generator-container">
                <!-- Controls injected here -->
            </div>

            <footer class="panel-footer">
                <button class="btn btn-primary" id="btn-rand">Randomize All</button>
                <div class="btn-row">
                    <button class="btn" id="btn-save-img">Save Image</button>
                    <button class="btn" id="btn-reset">Reset View</button>
                </div>
                <div class="btn-row">
                    <button class="btn" id="btn-save-json">Export Preset</button>
                    <button class="btn" id="btn-load-json">Import Preset</button>
                </div>
                <input type="file" id="json-input" style="display:none" accept=".json">
            </footer>
        </section>
    </aside>

    <div id="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title">
        <div class="modal-card">
            <h2 id="modal-title" class="modal-title">FEELING SALTY</h2>
            <p class="modal-text">
                Procedural Cubic Crystallization.<br>
                Simulates Scanning Electron Microscopy (SEM) imaging of salt-like structures.
            </p>
            <nav class="modal-links">
                <a href="https://pirillo.com/arcade/" target="_blank" class="modal-link">More Apps</a>
                <a href="https://chris.pirillo.com/" target="_blank" class="modal-link">Follow Chris</a>
                <a href="https://ctrlaltcreate.live/" target="_blank" class="modal-link">Learn More</a>
            </nav>
            <div class="modal-hint">Press ESC to close</div>
        </div>
    </div>

<script>
// --- CONFIGURATION ---
const DEFAULTS = {
    // Structure
    density: 300,
    scatter: 1.2,
    clumping: 0.8,
    baseScale: 0.8,
    variance: 0.4,
    deformation: 0.2,

    // Material
    textureType: 'cracked', 
    color: '#e8e8e8',
    colorVar: 0.15, 
    bg: '#050505',
    roughness: 0.2,
    metalness: 0.1,
    clearcoat: 0.3, 
    bump: 0.5,
    
    // Lighting
    beamIntensity: 2.5,
    beamAngle: 45,
    beamHeight: 60,
    rimLight: 1.0,
    fillLight: 0.3,
    shadowStrength: 0.8, 

    // Camera
    zoom: 35,
    vignette: 0.6,
    auto: 0
};

let PARAMS = { ...DEFAULTS };

// Internal State
let instancedMeshes = [];
let geometries = [];
let targetZoom = PARAMS.zoom;
let currentZoom = PARAMS.zoom;
let needsRebuild = false;
let needsReposition = false;
let autoTimer = null;

// --- TEXTURE FACTORY ---
const TextureFactory = {
    canvas: document.createElement('canvas'),
    ctx: null,
    
    init() {
        this.canvas.width = 512;
        this.canvas.height = 512;
        this.ctx = this.canvas.getContext('2d');
        return this.generate('cracked');
    },

    generate(type) {
        const ctx = this.ctx;
        const w = 512;
        const h = 512;

        // Reset to 50% Grey
        ctx.fillStyle = '#808080'; 
        ctx.fillRect(0, 0, w, h);
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Apply Patterns
        switch(type) {
            // FIXED ONES
            case 'cracked': this.drawCracks(ctx, w, h); break;
            case 'scratches': this.drawScratches(ctx, w, h); break;
            case 'wireframe': this.drawWireframe(ctx, w, h); break;
            case 'grooves': this.drawGrooves(ctx, w, h); break;
            case 'veins': this.drawVeins(ctx, w, h); break;
            case 'shards': this.drawShards(ctx, w, h); break;
            case 'geometric': this.drawGeometric(ctx, w, h); break; 

            // OTHERS
            case 'grain': this.addNoise(ctx, w, h, 80); break;
            case 'strata': this.drawStrata(ctx, w, h); break;
            case 'pitted': this.drawPitted(ctx, w, h); break;
            case 'brushed': this.drawBrushed(ctx, w, h); break;
            case 'wood': this.drawWood(ctx, w, h); break;
            case 'marble': this.drawMarble(ctx, w, h); break;
            case 'cellular': this.drawCellular(ctx, w, h); break;
            case 'fabric': this.drawFabric(ctx, w, h); break;
            case 'leather': this.addNoise(ctx, w, h, 40); this.drawCellular(ctx, w, h); break;
            case 'waves': this.drawWaves(ctx, w, h); break;
            case 'zigzag': this.drawZigZag(ctx, w, h); break;
            case 'hex': this.drawHex(ctx, w, h); break;
            case 'scales': this.drawScales(ctx, w, h); break;
            case 'circuit': this.drawCircuit(ctx, w, h); break;
            case 'maze': this.drawMaze(ctx, w, h); break;
            case 'dots': this.drawDots(ctx, w, h); break;
            case 'rings': this.drawRings(ctx, w, h); break;
            case 'checkers': this.drawCheckers(ctx, w, h); break;
            case 'tiles': this.drawTiles(ctx, w, h); break;
            case 'glitch': this.drawGlitch(ctx, w, h); break;
            case 'dunes': this.drawDunes(ctx, w, h); break;
            case 'fibers': this.drawFibers(ctx, w, h); break;
            case 'splatter': this.drawSplatter(ctx, w, h); break;
            case 'bubbles': this.drawBubbles(ctx, w, h); break;
            case 'sponge': this.drawSponge(ctx, w, h); break;
            case 'grid': this.drawGrid(ctx, w, h); break;
            case 'rust': this.drawRust(ctx, w, h); break;
            case 'frosted': this.addNoise(ctx, w, h, 200); break;
            case 'mosaic': this.drawMosaic(ctx, w, h); break;
            case 'bricks': this.drawBricks(ctx, w, h); break;
            case 'chainmail': this.drawChainmail(ctx, w, h); break;
            case 'wicker': this.drawWicker(ctx, w, h); break;
            case 'knurled': this.drawKnurled(ctx, w, h); break;
            case 'fingerprint': this.drawFingerprint(ctx, w, h); break;
            case 'ripples': this.drawRipples(ctx, w, h); break;
            case 'crumpled': this.drawCrumpled(ctx, w, h); break;
            case 'galvanized': this.drawGalvanized(ctx, w, h); break;
            case 'damascus': this.drawDamascus(ctx, w, h); break;
            case 'carbon': this.drawCarbon(ctx, w, h); break;
            case 'tread': this.drawTread(ctx, w, h); break;
            case 'gouged': this.drawGouged(ctx, w, h); break;
            case 'asphalt': this.drawAsphalt(ctx, w, h); break;
            case 'perforated': this.drawPerforated(ctx, w, h); break;
            case 'herringbone': this.drawHerringbone(ctx, w, h); break;
            case 'mica': this.drawMica(ctx, w, h); break;
            case 'obsidian': this.drawObsidian(ctx, w, h); break;
            case 'bamboo': this.drawBamboo(ctx, w, h); break;
            case 'stucco': this.drawStucco(ctx, w, h); break;
            case 'cratered': this.drawCratered(ctx, w, h); break;
            case 'nebula': this.drawNebula(ctx, w, h); break;
            case 'lava': this.drawLava(ctx, w, h); break;
            case 'crystal': this.drawCrystal(ctx, w, h); break;
            case 'denim': this.drawDenim(ctx, w, h); break;
            default: this.drawCracks(ctx, w, h); break;
        }

        ctx.restore();
        // Blur filter removed to ensure compatibility, relying on soft drawing brushes instead
        
        const texture = new THREE.CanvasTexture(this.canvas);
        texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
        return texture;
    },

    // --- REFACTORED: SUBTRACTIVE & ORGANIC ---
    
    drawCracks(ctx, w, h) {
        this.addNoise(ctx, w, h, 20); 
        ctx.strokeStyle = "rgba(40,40,40,0.7)"; 
        ctx.lineWidth = 2;
        const branch = (x, y, len, ang) => {
            if (len < 5) return;
            ctx.beginPath(); ctx.moveTo(x, y);
            let cx = x, cy = y;
            const segs = 5;
            for(let i=0; i<segs; i++) {
                ang += (Math.random()-0.5) * 0.8;
                cx += Math.cos(ang) * (len/segs); cy += Math.sin(ang) * (len/segs);
                ctx.lineTo(cx, cy);
            }
            ctx.stroke();
            if(Math.random() < 0.6) branch(cx, cy, len*0.6, ang + 0.6);
            if(Math.random() < 0.6) branch(cx, cy, len*0.6, ang - 0.6);
        };
        for(let i=0; i<8; i++) branch(Math.random()*w, Math.random()*h, 80 + Math.random()*100, Math.random()*Math.PI*2);
    },

    drawScratches(ctx, w, h) {
        this.addNoise(ctx, w, h, 10);
        for(let i=0; i<15; i++) {
            const cx = Math.random()*w, cy = Math.random()*h, baseAng = Math.random() * Math.PI * 2;
            for(let j=0; j<20; j++) {
                ctx.strokeStyle = `rgba(30,30,30,${Math.random()*0.3})`;
                ctx.lineWidth = 0.5 + Math.random();
                ctx.beginPath();
                const ox = cx + (Math.random()-0.5)*40, oy = cy + (Math.random()-0.5)*40;
                ctx.moveTo(ox, oy);
                const len = 20 + Math.random()*50, ang = baseAng + (Math.random()-0.5)*0.2;
                ctx.lineTo(ox + Math.cos(ang)*len, oy + Math.sin(ang)*len);
                ctx.stroke();
            }
        }
    },

    drawWireframe(ctx, w, h) {
        ctx.fillStyle = "#808080"; ctx.fillRect(0,0,w,h);
        ctx.strokeStyle = "#303030"; ctx.lineWidth = 3;
        const step = 64;
        for(let x=0; x<w; x+=step) if(Math.random()>0.3) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); }
        for(let y=0; y<h; y+=step) if(Math.random()>0.3) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
        ctx.fillStyle = "#505050"; 
        for(let x=step/2; x<w; x+=step) for(let y=step/2; y<h; y+=step) if(Math.random()>0.5) { ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill(); }
        this.addNoise(ctx, w, h, 10);
    },

    drawGrooves(ctx, w, h) {
        ctx.fillStyle = "#808080"; ctx.fillRect(0,0,w,h);
        for(let i=0; i<w; i+=25) { 
            const grad = ctx.createLinearGradient(i,0, i+15, 0);
            grad.addColorStop(0, "#808080"); grad.addColorStop(0.4, "#404040"); grad.addColorStop(1, "#808080");
            ctx.fillStyle = grad; ctx.fillRect(i, 0, 15, h);
        }
        this.addNoise(ctx, w, h, 20);
    },

    drawVeins(ctx, w, h) {
        ctx.fillStyle = "#707070"; ctx.fillRect(0,0,w,h);
        ctx.strokeStyle = "rgba(180,180,180,0.4)"; ctx.lineWidth = 4;
        const branch = (x, y, len, ang, width) => {
            if (len < 5 || width < 0.5) return;
            ctx.lineWidth = width; ctx.beginPath(); ctx.moveTo(x, y);
            const ex = x + Math.cos(ang)*len, ey = y + Math.sin(ang)*len;
            const cx = (x+ex)/2 + (Math.random()-0.5)*len*0.5, cy = (y+ey)/2 + (Math.random()-0.5)*len*0.5;
            ctx.quadraticCurveTo(cx, cy, ex, ey); ctx.stroke();
            if(Math.random()<0.7) branch(ex, ey, len*0.8, ang + 0.5, width*0.8);
            if(Math.random()<0.7) branch(ex, ey, len*0.8, ang - 0.5, width*0.8);
        };
        for(let i=0; i<6; i++) branch(Math.random()*w, Math.random()*h, 100, Math.random()*Math.PI*2, 6);
    },

    drawShards(ctx, w, h) {
        for(let i=0; i<30; i++) {
            const x = Math.random() * w, y = Math.random() * h, s = 50 + Math.random() * 150;
            const g = ctx.createLinearGradient(x-s, y-s, x+s, y+s);
            const shade = 128 + (Math.random()-0.5)*100;
            g.addColorStop(0, `rgb(${shade},${shade},${shade})`);
            g.addColorStop(0.5, `rgb(${shade},${shade},${shade})`);
            g.addColorStop(0.51, `rgb(${shade-60},${shade-60},${shade-60})`);
            g.addColorStop(1, `rgb(${shade-60},${shade-60},${shade-60})`);
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.moveTo(x, y);
            ctx.lineTo(x + (Math.random()-0.5)*s, y + (Math.random()-0.5)*s);
            ctx.lineTo(x + (Math.random()-0.5)*s, y + (Math.random()-0.5)*s);
            ctx.fill();
        }
    },

    // --- REWRITTEN GEOMETRIC ---
    drawGeometric(ctx, w, h) {
        // Voronoi-style crystalline facets
        const points = [];
        for(let i=0; i<30; i++) points.push({x: Math.random()*w, y: Math.random()*h});
        
        for(let y=0; y<h; y+=2) {
            for(let x=0; x<w; x+=2) {
                let d1 = 9999, d2 = 9999;
                let closest = 0;
                
                for(let i=0; i<points.length; i++) {
                    const d = Math.hypot(x - points[i].x, y - points[i].y);
                    if(d < d1) { d2 = d1; d1 = d; closest = i; }
                    else if(d < d2) { d2 = d; }
                }
                
                // Color based on cell ID + distance from center
                // This creates distinct faceted gradients per cell
                const seed = closest * 12345;
                const baseVal = 100 + (Math.sin(seed)*50 + 50);
                const grad = (d1 / (d1+d2)) * 100; // Edge darkening
                
                const val = Math.min(255, baseVal - grad);
                ctx.fillStyle = `rgb(${val},${val},${val})`;
                ctx.fillRect(x, y, 2, 2);
            }
        }
    },

    // --- UTILS ---
    addNoise(ctx, w, h, amount) {
        const id = ctx.getImageData(0,0,w,h);
        const data = id.data;
        for(let i=0; i<data.length; i+=4){
            const v = (Math.random()-0.5) * amount;
            data[i] = Math.max(0, Math.min(255, data[i] + v));
            data[i+1] = Math.max(0, Math.min(255, data[i+1] + v));
            data[i+2] = Math.max(0, Math.min(255, data[i+2] + v));
        }
        ctx.putImageData(id,0,0);
    },

    // --- OTHER GENERATORS ---
    drawStrata(ctx,w,h) { for(let y=0;y<h;y+=4){ ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.5})`; ctx.fillRect(0,y,w,2+Math.random()*4); } this.addNoise(ctx,w,h,20); },
    drawPitted(ctx,w,h) { for(let i=0;i<100;i++){ const x=Math.random()*w,y=Math.random()*h,r=2+Math.random()*15; const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,"rgba(0,0,0,0.6)"); g.addColorStop(1,"rgba(128,128,128,0)"); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } this.addNoise(ctx,w,h,30); },
    drawBrushed(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.05)"; for(let i=0;i<1000;i++){ const x=Math.random()*w; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x+Math.random()*20,h); ctx.stroke(); } this.addNoise(ctx,w,h,10); },
    drawWood(ctx,w,h) { for(let i=0;i<w;i+=2){ const d=Math.abs(i-w/2); const v=Math.sin(d*0.1+Math.random()*0.5)*0.5+0.5; ctx.fillStyle=`rgba(255,255,255,${v*0.1})`; ctx.fillRect(i,0,2,h); } this.addNoise(ctx,w,h,15); },
    drawMarble(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.lineWidth=10; for(let i=0;i<10;i++){ ctx.beginPath(); ctx.moveTo(0,Math.random()*h); ctx.bezierCurveTo(w/3,Math.random()*h,2*w/3,Math.random()*h,w,Math.random()*h); ctx.stroke(); } this.addNoise(ctx,w,h,20); },
    drawCellular(ctx,w,h) { const p=[]; for(let i=0;i<40;i++) p.push({x:Math.random()*w,y:Math.random()*h}); for(let y=0;y<h;y+=8) for(let x=0;x<w;x+=8){ let d=9999; p.forEach(pt=>{const dist=Math.hypot(x-pt.x,y-pt.y); if(dist<d)d=dist;}); const v=Math.min(255,d*2); ctx.fillStyle=`rgb(${128+v/2},${128+v/2},${128+v/2})`; ctx.fillRect(x,y,8,8); } },
    drawFabric(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.15)"; for(let i=0;i<w;i+=4){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,h);ctx.stroke();} for(let i=0;i<h;i+=4){ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(w,i);ctx.stroke();} this.addNoise(ctx,w,h,20); },
    drawWaves(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.2)"; for(let y=0;y<h;y+=20){ctx.beginPath(); for(let x=0;x<w;x+=10) ctx.lineTo(x,y+Math.sin(x*0.05)*10); ctx.stroke();} },
    drawZigZag(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)"; for(let y=0;y<h;y+=30){ctx.beginPath(); ctx.moveTo(0,y); for(let x=0;x<w;x+=20) ctx.lineTo(x+10,y+(x%40?10:-10)); ctx.stroke();} },
    drawHex(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)"; const r=30; for(let y=0;y<h;y+=r*1.5) for(let x=0;x<w;x+=r*1.732){ ctx.beginPath(); for(let i=0;i<6;i++){const a=i*Math.PI/3; ctx.lineTo(x+r*Math.cos(a),y+r*Math.sin(a));} ctx.closePath(); ctx.stroke(); } },
    drawScales(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)"; for(let y=0;y<h;y+=20) for(let x=0;x<w;x+=20){ ctx.beginPath(); ctx.arc(x+(y%40?10:0),y,10,0,Math.PI); ctx.stroke(); } },
    drawCircuit(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.5)"; ctx.lineWidth=2; let x=w/2,y=h/2; for(let i=0;i<100;i++){ ctx.beginPath(); ctx.moveTo(x,y); if(Math.random()>0.5)x+=(Math.random()-0.5)*100; else y+=(Math.random()-0.5)*100; ctx.lineTo(x,y); ctx.stroke(); ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill(); } },
    drawMaze(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.5)"; ctx.lineWidth=4; for(let x=0;x<w;x+=20) for(let y=0;y<h;y+=20){ ctx.beginPath(); ctx.moveTo(x,y); if(Math.random()>0.5) ctx.lineTo(x+20,y+20); else ctx.lineTo(x+20,y-20); ctx.stroke(); } },
    drawDots(ctx,w,h) { ctx.fillStyle="rgba(255,255,255,0.5)"; for(let y=0;y<h;y+=30) for(let x=0;x<w;x+=30){ ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill(); } },
    drawRings(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)"; for(let i=0;i<50;i++){ ctx.beginPath(); ctx.arc(Math.random()*w, Math.random()*h, 10+Math.random()*50,0,Math.PI*2); ctx.stroke(); } },
    drawCheckers(ctx,w,h) { ctx.fillStyle="rgba(255,255,255,0.2)"; for(let y=0;y<h;y+=64) for(let x=0;x<w;x+=64) if((x/64+y/64)%2===0) ctx.fillRect(x,y,64,64); this.addNoise(ctx,w,h,20); },
    drawTiles(ctx,w,h) { ctx.fillStyle="rgba(255,255,255,0.2)"; for(let y=0;y<h;y+=40) for(let x=0;x<w;x+=80) ctx.fillRect(x+(y%80?40:0)+2,y+2,76,36); },
    drawGlitch(ctx,w,h) { for(let y=0;y<h;y+=2) if(Math.random()>0.9){ ctx.fillStyle=`rgba(255,255,255,${Math.random()})`; ctx.fillRect(0,y,w,Math.random()*10); } },
    drawDunes(ctx,w,h) { for(let y=0;y<h;y++){ const v=Math.sin(y*0.05+Math.sin(y*0.01)*5)*127+128; ctx.fillStyle=`rgb(${128+v/4},${128+v/4},${128+v/4})`; ctx.fillRect(0,y,w,1); } },
    drawFibers(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.2)"; for(let i=0;i<2000;i++){ const x=Math.random()*w,y=Math.random()*h; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+10,y+10); ctx.stroke(); } },
    drawSplatter(ctx,w,h) { ctx.fillStyle="rgba(255,255,255,0.8)"; for(let i=0;i<50;i++){ const x=Math.random()*w,y=Math.random()*h,r=Math.random()*20; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); for(let j=0;j<5;j++){ ctx.beginPath(); ctx.arc(x+Math.random()*r*2-r,y+Math.random()*r*2-r,r/4,0,Math.PI*2); ctx.fill(); } } },
    drawBubbles(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.4)"; for(let i=0;i<200;i++){ ctx.beginPath(); ctx.arc(Math.random()*w,Math.random()*h,Math.random()*10,0,Math.PI*2); ctx.stroke(); } },
    drawSponge(ctx,w,h) { this.addNoise(ctx,w,h,100); for(let i=0;i<500;i++) ctx.clearRect(Math.random()*w,Math.random()*h,Math.random()*5,Math.random()*5); },
    drawGrid(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.4)"; for(let i=0;i<w;i+=50){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i,h);ctx.stroke();} for(let i=0;i<h;i+=50){ctx.beginPath();ctx.moveTo(0,i);ctx.lineTo(w,i);ctx.stroke();} },
    drawRust(ctx,w,h) { for(let i=0;i<50;i++){ const x=Math.random()*w,y=Math.random()*h,r=Math.random()*50; const g=ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0,"rgba(255,255,255,0.4)"); g.addColorStop(1,"rgba(0,0,0,0)"); ctx.fillStyle=g; ctx.fillRect(0,0,w,h); } this.addNoise(ctx,w,h,60); },
    drawMosaic(ctx,w,h) { for(let y=0;y<h;y+=16) for(let x=0;x<w;x+=16){ ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.5})`; ctx.fillRect(x+1,y+1,14,14); } },
    drawBricks(ctx,w,h) { ctx.fillStyle="#999";ctx.fillRect(0,0,w,h);ctx.fillStyle="#bbb";const bw=64,bh=32;for(let y=0;y<h;y+=bh){const o=(y/bh)%2===0?0:bw/2;for(let x=-bw;x<w;x+=bw)ctx.fillRect(x+o+2,y+2,bw-4,bh-4);} this.addNoise(ctx,w,h,20); },
    drawChainmail(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.4)";ctx.lineWidth=4;for(let y=0;y<h;y+=16)for(let x=0;x<w;x+=16){ctx.beginPath();ctx.arc(x+(y%32?8:0),y,10,0,Math.PI*2);ctx.stroke();} },
    drawWicker(ctx,w,h) { ctx.fillStyle="#aaa";ctx.fillRect(0,0,w,h);for(let y=0;y<h;y+=32)for(let x=0;x<w;x+=32){ctx.fillStyle=((x/32+y/32)%2===0)?"#ccc":"#888";ctx.fillRect(x,y,32,32);ctx.fillStyle="rgba(0,0,0,0.2)";if((x/32+y/32)%2===0)ctx.fillRect(x+4,y,24,32);else ctx.fillRect(x,y+4,32,24);} },
    drawKnurled(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)";ctx.lineWidth=2;for(let i=-w;i<w*2;i+=10){ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i+h,h);ctx.stroke();ctx.beginPath();ctx.moveTo(i,0);ctx.lineTo(i-h,h);ctx.stroke();} },
    drawFingerprint(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.4)";ctx.lineWidth=2;const cx=w/2,cy=h/2;for(let r=0;r<300;r+=6){ctx.beginPath();for(let a=0;a<Math.PI*2;a+=0.1){const n=Math.sin(a*10+r*0.1)*5;ctx.lineTo(cx+Math.cos(a)*(r+n),cy+Math.sin(a)*(r+n));}ctx.stroke();} },
    drawRipples(ctx,w,h) { for(let i=0;i<20;i++){const x=Math.random()*w,y=Math.random()*h;for(let r=0;r<50;r+=5){ctx.strokeStyle=`rgba(255,255,255,${1-r/50})`;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.stroke();}} },
    drawCrumpled(ctx,w,h) { for(let i=0;i<50;i++){const g=ctx.createLinearGradient(0,0,w,h);g.addColorStop(0,"rgba(255,255,255,0)");g.addColorStop(0.5,"rgba(255,255,255,0.2)");g.addColorStop(1,"rgba(255,255,255,0)");ctx.fillStyle=g;ctx.save();ctx.translate(Math.random()*w,Math.random()*h);ctx.rotate(Math.random()*Math.PI);ctx.fillRect(-w,-20,w*2,40);ctx.restore();} },
    drawGalvanized(ctx,w,h) { for(let i=0;i<200;i++){ctx.fillStyle=`rgb(${100+Math.random()*155},${100+Math.random()*155},${100+Math.random()*155})`;ctx.beginPath();const x=Math.random()*w,y=Math.random()*h;ctx.moveTo(x,y);for(let j=0;j<6;j++)ctx.lineTo(x+(Math.random()-0.5)*80,y+(Math.random()-0.5)*80);ctx.fill();} },
    drawDamascus(ctx,w,h) { for(let y=0;y<h;y+=2){const n=Math.sin(y*0.05+Math.sin(y*0.01)*5)*20;ctx.strokeStyle=`rgb(${128+n*2},${128+n*2},${128+n*2})`;ctx.beginPath();ctx.moveTo(0,y+n);ctx.lineTo(w,y+n);ctx.stroke();} },
    drawCarbon(ctx,w,h) { const s=16;for(let y=0;y<h;y+=s)for(let x=0;x<w;x+=s){const check=(x/s+y/s)%2===0;const g=ctx.createLinearGradient(x,y,x+s,y+s);if(check){g.addColorStop(0,"#444");g.addColorStop(1,"#aaa");}else{g.addColorStop(0,"#aaa");g.addColorStop(1,"#444");}ctx.fillStyle=g;ctx.fillRect(x,y,s,s);} },
    drawTread(ctx,w,h) { ctx.fillStyle="#333";ctx.fillRect(0,0,w,h);ctx.fillStyle="#888";for(let y=0;y<h;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w/2,y+30);ctx.lineTo(w,y);ctx.lineTo(w,y+20);ctx.lineTo(w/2,y+50);ctx.lineTo(0,y+20);ctx.fill();} },
    drawGouged(ctx,w,h) { ctx.strokeStyle="rgba(0,0,0,0.6)";ctx.lineWidth=4;for(let i=0;i<30;i++){ctx.lineWidth=2+Math.random()*6;ctx.beginPath();ctx.moveTo(Math.random()*w,Math.random()*h);ctx.lineTo(Math.random()*w,Math.random()*h);ctx.stroke();} this.addNoise(ctx,w,h,20); },
    drawAsphalt(ctx,w,h) { this.addNoise(ctx,w,h,255);for(let i=0;i<500;i++){const v=Math.random()*100;ctx.fillStyle=`rgb(${v},${v},${v})`;ctx.fillRect(Math.random()*w,Math.random()*h,2+Math.random()*4,2+Math.random()*4);} },
    drawPerforated(ctx,w,h) { ctx.fillStyle="#ccc";ctx.fillRect(0,0,w,h);ctx.fillStyle="#444";for(let y=0;y<h;y+=20)for(let x=0;x<w;x+=20){ctx.beginPath();ctx.arc(x+(y%40?10:0),y,6,0,Math.PI*2);ctx.fill();} },
    drawHerringbone(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.3)";for(let y=0;y<h;y+=20){ctx.beginPath();for(let x=0;x<w;x+=20){ctx.moveTo(x,y);ctx.lineTo(x+10,y-10);ctx.moveTo(x+10,y-10);ctx.lineTo(x+20,y);}ctx.stroke();} },
    drawMica(ctx,w,h) { for(let i=0;i<200;i++){ctx.fillStyle=`rgba(255,255,255,${Math.random()*0.1})`;ctx.beginPath();ctx.arc(Math.random()*w,Math.random()*h,20+Math.random()*50,0,Math.PI*2);ctx.fill();} },
    drawObsidian(ctx,w,h) { for(let i=0;i<20;i++){const x=Math.random()*w,y=Math.random()*h,r=50+Math.random()*100;const g=ctx.createRadialGradient(x,y,0,x,y,r);g.addColorStop(0,"rgba(255,255,255,0.2)");g.addColorStop(1,"rgba(0,0,0,0)");ctx.fillStyle=g;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();} },
    drawBamboo(ctx,w,h) { for(let x=0;x<w;x+=40){const g=ctx.createLinearGradient(x,0,x+40,0);g.addColorStop(0,"#888");g.addColorStop(0.5,"#ddd");g.addColorStop(1,"#888");ctx.fillStyle=g;ctx.fillRect(x,0,40,h);}ctx.fillStyle="#444";for(let y=0;y<h;y+=100+Math.random()*100)ctx.fillRect(0,y,w,3);this.drawFibers(ctx,w,h); },
    drawStucco(ctx,w,h) { this.addNoise(ctx,w,h,100);ctx.fillStyle="rgba(0,0,0,0.1)";for(let i=0;i<1000;i++)ctx.fillRect(Math.random()*w,Math.random()*h,2,2); },
    drawCratered(ctx,w,h) { for(let i=0;i<20;i++){const x=Math.random()*w,y=Math.random()*h,r=20+Math.random()*60;const g=ctx.createRadialGradient(x,y,r*0.8,x,y,r);g.addColorStop(0,"rgba(0,0,0,0.5)");g.addColorStop(1,"rgba(255,255,255,0.5)");ctx.fillStyle=g;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();} },
    drawNebula(ctx,w,h) { for(let i=0;i<50;i++){const x=Math.random()*w,y=Math.random()*h,r=100+Math.random()*100;const g=ctx.createRadialGradient(x,y,0,x,y,r);g.addColorStop(0,`rgba(255,255,255,${Math.random()*0.2})`);g.addColorStop(1,"rgba(0,0,0,0)");ctx.fillStyle=g;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();} },
    drawLava(ctx,w,h) { this.drawCracks(ctx,w,h);ctx.fillStyle="rgba(128,128,128,0.5)";for(let i=0;i<20;i++){ctx.beginPath();ctx.arc(Math.random()*w,Math.random()*h,20+Math.random()*40,0,Math.PI*2);ctx.fill();} },
    drawCrystal(ctx,w,h) { for(let i=0;i<50;i++){ctx.fillStyle=`rgb(${100+Math.random()*155},${100+Math.random()*155},${100+Math.random()*155})`;ctx.beginPath();ctx.moveTo(Math.random()*w,Math.random()*h);ctx.lineTo(Math.random()*w,Math.random()*h);ctx.lineTo(Math.random()*w,Math.random()*h);ctx.fill();} },
    drawDenim(ctx,w,h) { ctx.strokeStyle="rgba(255,255,255,0.2)";for(let x=0;x<w;x+=2){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x-h,h);ctx.stroke();} this.addNoise(ctx,w,h,40); }
};

const TEXTURE_OPTIONS = [
    'cracked', 'grain', 'strata', 'pitted', 'geometric',
    'brushed', 'wood', 'marble', 'cellular', 'fabric',
    'leather', 'waves', 'zigzag', 'hex', 'scales',
    'circuit', 'maze', 'dots', 'rings', 'checkers',
    'tiles', 'glitch', 'shards', 'dunes', 'fibers',
    'splatter', 'bubbles', 'veins', 'sponge', 'scratches',
    'grooves', 'grid', 'rust', 'frosted', 'mosaic',
    'bricks', 'chainmail', 'wicker', 'knurled', 'fingerprint',
    'ripples', 'crumpled', 'galvanized', 'damascus', 'carbon',
    'tread', 'gouged', 'asphalt', 'perforated', 'herringbone',
    'mica', 'obsidian', 'bamboo', 'wireframe', 'stucco',
    'cratered', 'nebula', 'lava', 'crystal', 'denim'
];

const UI_GROUPS = [
    {
        title: "Structure",
        id: "geo",
        controls: [
            { id: 'density', label: 'Count', min: 10, max: 800, step: 10 },
            { id: 'scatter', label: 'Scatter', min: 0.1, max: 4.0, step: 0.1 },
            { id: 'clumping', label: 'Clumping', min: 0, max: 1, step: 0.01 },
            { id: 'baseScale', label: 'Base Size', min: 0.1, max: 2.0, step: 0.1 },
            { id: 'variance', label: 'Size Variance', min: 0, max: 1, step: 0.05 },
            { id: 'deformation', label: 'Deformation', min: 0, max: 1, step: 0.05, triggerRebuild: true }
        ]
    },
    {
        title: "Material & Surface",
        id: "mat",
        controls: [
            { id: 'textureType', label: 'Surface Texture', type: 'select', options: TEXTURE_OPTIONS },
            { id: 'color', label: 'Base Color', type: 'color' },
            { id: 'colorVar', label: 'Color Variation', min: 0, max: 0.5, step: 0.01, triggerColor: true },
            { id: 'roughness', label: 'Roughness', min: 0, max: 1, step: 0.05 },
            { id: 'metalness', label: 'Metalness', min: 0, max: 1, step: 0.05 },
            { id: 'clearcoat', label: 'Polish (Clearcoat)', min: 0, max: 1, step: 0.05 },
            { id: 'bump', label: 'Surface Depth', min: 0, max: 2.0, step: 0.01 },
            { id: 'bg', label: 'Background', type: 'color' },
        ]
    },
    {
        title: "Lighting (SEM Beam)",
        id: "lit",
        controls: [
            { id: 'beamIntensity', label: 'Beam Power', min: 0, max: 5, step: 0.1 },
            { id: 'shadowStrength', label: 'Shadow Contrast', min: 0, max: 1, step: 0.05 },
            { id: 'beamAngle', label: 'Azimuth', min: 0, max: 360, step: 1 },
            { id: 'beamHeight', label: 'Elevation', min: 0, max: 90, step: 1 },
            { id: 'rimLight', label: 'Edge Highlight', min: 0, max: 5, step: 0.1 },
            { id: 'fillLight', label: 'Fill / Ambient', min: 0, max: 2, step: 0.05 }
        ]
    },
    {
        title: "Optics",
        id: "sys",
        controls: [
            { id: 'zoom', label: 'Magnification', min: 10, max: 100, step: 1 },
            { id: 'vignette', label: 'Vignette', min: 0, max: 1, step: 0.05 },
            { id: 'auto', label: 'Auto-Timer (s)', min: 0, max: 10, step: 1 }
        ]
    }
];

// --- 3D ENGINE ---
const container = document.getElementById('canvas-container');
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(PARAMS.zoom, window.innerWidth / window.innerHeight, 0.1, 500);
camera.position.set(0, 15, 25);

const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
container.appendChild(renderer.domElement);

// Environment
const pmremGenerator = new THREE.PMREMGenerator(renderer);
pmremGenerator.compileEquirectangularShader();

function generateEnvironment() {
    const envScene = new THREE.Scene();
    envScene.background = new THREE.Color(0x222222);
    const boxGeo = new THREE.BoxGeometry(1,1,1);
    const boxMat = new THREE.MeshBasicMaterial({color: 0xcccccc}); // Dimmed from white
    for(let i=0; i<6; i++) {
        const mesh = new THREE.Mesh(boxGeo, boxMat);
        mesh.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*20, (Math.random()-0.5)*20);
        mesh.scale.set(2,2,2);
        envScene.add(mesh);
    }
    const canvas = document.createElement('canvas');
    canvas.width = 256; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const grd = ctx.createLinearGradient(0,0,0,128);
    grd.addColorStop(0, "#444");
    grd.addColorStop(1, "#000");
    ctx.fillStyle = grd;
    ctx.fillRect(0,0,256,128);
    const cubeRenderTarget = pmremGenerator.fromScene(envScene, 0.04);
    scene.environment = cubeRenderTarget.texture;
}
generateEnvironment();

// Lights
const ambient = new THREE.HemisphereLight(0xffffff, 0x000000, PARAMS.fillLight);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, PARAMS.beamIntensity);
sun.castShadow = true;
sun.shadow.mapSize.set(2048, 2048);
sun.shadow.bias = -0.00005;
sun.shadow.radius = 4; 
scene.add(sun);

const rim = new THREE.SpotLight(0xffffff, PARAMS.rimLight);
rim.position.set(-10, 10, -20);
scene.add(rim);

// Material
const bumpMap = TextureFactory.init();

const material = new THREE.MeshPhysicalMaterial({
    color: PARAMS.color,
    roughness: PARAMS.roughness,
    metalness: PARAMS.metalness,
    clearcoat: PARAMS.clearcoat,
    clearcoatRoughness: 0.1,
    bumpMap: bumpMap,
    bumpScale: PARAMS.bump,
});

// Geometry Factory
function buildGeometries() {
    geometries.forEach(g => g.dispose());
    geometries = [];

    for(let i=0; i<3; i++) {
        const geo = new THREE.BoxGeometry(1, 1, 1, 16, 16, 16);
        if(PARAMS.deformation > 0.01) {
            const pos = geo.attributes.position;
            const v = new THREE.Vector3();
            const offset = i * 233.5; 
            for(let k=0; k<pos.count; k++) {
                v.fromBufferAttribute(pos, k);
                const normalized = v.clone().normalize();
                const freq = 6;
                const amp = 0.25 * PARAMS.deformation;
                const nx = Math.sin(v.y*freq + offset) * Math.cos(v.z*freq + offset);
                const ny = Math.sin(v.x*freq + offset) * Math.cos(v.z*freq + offset);
                const nz = Math.sin(v.x*freq + offset) * Math.cos(v.y*freq + offset);
                v.add(new THREE.Vector3(nx, ny, nz).multiplyScalar(amp));
                if(PARAMS.deformation > 0.6) v.lerp(normalized, (PARAMS.deformation - 0.6) * 0.4);
                pos.setXYZ(k, v.x, v.y, v.z);
            }
            geo.computeVertexNormals();
        }
        geometries.push(geo);
    }
}

// Color Utility
function applyColors() {
    const baseColor = new THREE.Color(PARAMS.color);
    const tempColor = new THREE.Color();
    instancedMeshes.forEach((mesh, meshIdx) => {
        for (let i = 0; i < mesh.count; i++) {
            const seed = (meshIdx * 1000) + i;
            const rnd = Math.sin(seed) * 0.5 + 0.5; 
            const variation = (rnd - 0.5) * PARAMS.colorVar * 2; 
            tempColor.copy(baseColor);
            tempColor.offsetHSL(0, 0, variation); 
            mesh.setColorAt(i, tempColor);
        }
        mesh.instanceColor.needsUpdate = true;
    });
}

function updateScene(fullRegen = false) {
    if(fullRegen) {
        instancedMeshes.forEach(m => { scene.remove(m); m.dispose(); });
        instancedMeshes = [];
    }

    // Light
    const r = 40;
    const phi = THREE.MathUtils.degToRad(90 - PARAMS.beamHeight);
    const theta = THREE.MathUtils.degToRad(PARAMS.beamAngle);
    sun.position.set(r * Math.sin(phi) * Math.cos(theta), r * Math.cos(phi), r * Math.sin(phi) * Math.sin(theta));
    sun.lookAt(0,0,0);
    sun.intensity = PARAMS.beamIntensity;
    ambient.intensity = PARAMS.fillLight * (1 - PARAMS.shadowStrength * 0.5);
    rim.intensity = PARAMS.rimLight;

    // Material
    material.color.set(PARAMS.color);
    material.roughness = PARAMS.roughness;
    material.metalness = PARAMS.metalness;
    material.clearcoat = PARAMS.clearcoat;
    material.bumpScale = PARAMS.bump;

    scene.background = new THREE.Color(PARAMS.bg);
    scene.fog = new THREE.Fog(PARAMS.bg, 20, 150);
    document.getElementById('vignette').style.opacity = PARAMS.vignette;

    if(!fullRegen && instancedMeshes.length > 0) {
        applyColors();
        return;
    }

    // Instances
    const countPerGeo = Math.ceil(PARAMS.density / geometries.length);
    const dummy = new THREE.Object3D();

    geometries.forEach((geo) => {
        const mesh = new THREE.InstancedMesh(geo, material, countPerGeo);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        for(let i=0; i<countPerGeo; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            // Decoupled logic:
            // Scatter = Max Radius bounds
            // Clumping = Distribution curve (0.33 = Uniform Volume, 4.0 = Center Bias)
            const spread = 15 * PARAMS.scatter;
            const distPower = 0.33 + (PARAMS.clumping * 3.7); 
            const r = Math.pow(Math.random(), distPower) * spread; 

            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);

            const s = PARAMS.baseScale * (1 + (Math.random() - 0.5) * PARAMS.variance);
            dummy.position.set(x, y, z);
            dummy.rotation.set(Math.random()*6.28, Math.random()*6.28, Math.random()*6.28);
            dummy.scale.set(s, s, s); 
            dummy.updateMatrix();
            mesh.setMatrixAt(i, dummy.matrix);
        }
        scene.add(mesh);
        instancedMeshes.push(mesh);
    });
    applyColors();
}

// --- UI GENERATION ---
const uiContainer = document.getElementById('generator-container');

function initUI() {
    uiContainer.innerHTML = '';
    UI_GROUPS.forEach((group, idx) => {
        const el = document.createElement('details');
        el.className = 'control-group';
        if(idx === 0 || idx === 1) el.open = true;
        
        const sum = document.createElement('summary');
        sum.innerText = group.title;
        el.appendChild(sum);

        const body = document.createElement('div');
        body.className = 'group-body';

        group.controls.forEach(ctrl => {
            const row = document.createElement('div');
            
            if(ctrl.type === 'color') {
                row.className = 'ctrl-row';
                row.innerHTML = `<div class="ctrl-header"><span class="ctrl-label">${ctrl.label}</span></div>
                    <div class="color-wrap"><input type="color" id="p-${ctrl.id}" value="${PARAMS[ctrl.id]}"></div>`;
            } else if (ctrl.type === 'select') {
                row.className = 'ctrl-row';
                let opts = ctrl.options.map(o => `<option value="${o}" ${PARAMS[ctrl.id]===o?'selected':''}>${o.charAt(0).toUpperCase() + o.slice(1)}</option>`).join('');
                row.innerHTML = `<div class="ctrl-header"><span class="ctrl-label">${ctrl.label}</span></div>
                    <select id="p-${ctrl.id}">${opts}</select>`;
            } else {
                row.className = 'ctrl-row';
                row.innerHTML = `<div class="ctrl-header"><span class="ctrl-label">${ctrl.label}</span><span class="ctrl-val" id="v-${ctrl.id}">${PARAMS[ctrl.id]}</span></div>
                    <input type="range" id="p-${ctrl.id}" min="${ctrl.min}" max="${ctrl.max}" step="${ctrl.step || 0.1}" value="${PARAMS[ctrl.id]}">`;
            }
            body.appendChild(row);
        });
        el.appendChild(body);
        uiContainer.appendChild(el);
    });
    bindEvents();
}

function bindEvents() {
    UI_GROUPS.forEach(g => {
        g.controls.forEach(c => {
            const input = document.getElementById(`p-${c.id}`);
            const display = document.getElementById(`v-${c.id}`);

            input.addEventListener('input', (e) => {
                let val = e.target.value;
                if(c.type !== 'color' && c.type !== 'select') val = parseFloat(val);
                
                PARAMS[c.id] = val;
                if(display) display.innerText = (typeof val === 'number' && val % 1 === 0) ? val : (typeof val === 'number' ? val.toFixed(2) : val);

                if(c.id === 'zoom') targetZoom = val;
                else if(c.triggerRebuild) needsRebuild = true;
                else if(['density','scatter','clumping','baseScale','variance'].includes(c.id)) needsReposition = true;
                else if(c.id === 'auto') handleAuto();
                else if(c.id === 'textureType') {
                    material.bumpMap = TextureFactory.generate(val);
                    material.needsUpdate = true;
                }
                else updateScene(false);
            });

            if(c.triggerRebuild || ['density','scatter','clumping','baseScale','variance'].includes(c.id)) {
                 input.addEventListener('change', () => {
                     if(needsRebuild) { buildGeometries(); needsRebuild = false; }
                     updateScene(true);
                 });
            }
        });
    });
}

function refreshUI() {
    UI_GROUPS.forEach(g => {
        g.controls.forEach(c => {
            const input = document.getElementById(`p-${c.id}`);
            const display = document.getElementById(`v-${c.id}`);
            if(input) input.value = PARAMS[c.id];
            if(display) display.innerText = (typeof PARAMS[c.id] === 'number' && PARAMS[c.id] % 1 !== 0) ? PARAMS[c.id].toFixed(2) : PARAMS[c.id];
        });
    });
}

// --- INTERACTION ---
const orbit = { rx: 0, ry: 0, trTx: 0, trTy: 0, dist: 25, isDown: false, lx: 0, ly: 0 };
container.addEventListener('mousedown', e => { orbit.isDown = true; orbit.lx = e.clientX; orbit.ly = e.clientY; });
window.addEventListener('mouseup', () => orbit.isDown = false);
window.addEventListener('mousemove', e => {
    if(orbit.isDown) {
        const dx = e.clientX - orbit.lx;
        const dy = e.clientY - orbit.ly;
        orbit.rx += dx * 0.005;
        orbit.ry += dy * 0.005;
        orbit.ry = Math.max(-1.5, Math.min(1.5, orbit.ry));
        orbit.lx = e.clientX; orbit.ly = e.clientY;
    }
});
window.addEventListener('wheel', e => {
    if(document.getElementById('controls-panel').contains(e.target)) return;
    targetZoom = Math.max(10, Math.min(120, targetZoom + e.deltaY * 0.05));
}, {passive:false});

function updateCamera() {
    if(Math.abs(targetZoom - currentZoom) > 0.1) {
        currentZoom += (targetZoom - currentZoom) * 0.1;
        camera.fov = currentZoom;
        camera.updateProjectionMatrix();
        const zInp = document.getElementById('p-zoom');
        if(zInp && document.activeElement !== zInp) {
            zInp.value = currentZoom;
            document.getElementById('v-zoom').innerText = Math.round(currentZoom);
        }
    }
    const cx = Math.sin(orbit.rx) * Math.cos(orbit.ry) * orbit.dist;
    const cy = Math.sin(orbit.ry) * orbit.dist;
    const cz = Math.cos(orbit.rx) * Math.cos(orbit.ry) * orbit.dist;
    camera.position.set(cx, cy, cz);
    camera.lookAt(0,0,0);
}

// --- SYSTEM ---
function randomize() {
    const fade = document.getElementById('fade-overlay');
    fade.style.opacity = 1;
    setTimeout(() => {
        PARAMS.density = 100 + Math.floor(Math.random() * 400);
        PARAMS.scatter = 0.5 + Math.random() * 2.0;
        PARAMS.clumping = Math.random();
        PARAMS.baseScale = 0.4 + Math.random();
        PARAMS.deformation = Math.random() * 0.4;
        
        const types = TEXTURE_OPTIONS;
        PARAMS.textureType = types[Math.floor(Math.random()*types.length)];
        material.bumpMap = TextureFactory.generate(PARAMS.textureType);

        PARAMS.roughness = Math.random();
        PARAMS.metalness = Math.random() * 0.5;
        PARAMS.clearcoat = Math.random();
        PARAMS.beamAngle = Math.random() * 360;
        PARAMS.beamHeight = 20 + Math.random() * 70;
        
        targetZoom = 20 + Math.random() * 50;
        orbit.rx = Math.random() * 6.28;
        orbit.ry = (Math.random() - 0.5);

        refreshUI();
        buildGeometries();
        updateScene(true);
        fade.style.opacity = 0;
    }, 250);
}

function handleAuto() {
    if(autoTimer) clearInterval(autoTimer);
    if(PARAMS.auto > 0) autoTimer = setInterval(randomize, PARAMS.auto * 1000);
}

// JSON I/O
function exportData() {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(PARAMS));
    const el = document.createElement('a');
    el.setAttribute("href", dataStr);
    el.setAttribute("download", "salty_preset.json");
    el.click();
}
function importData(e) {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const loaded = JSON.parse(ev.target.result);
            Object.assign(PARAMS, loaded);
            targetZoom = PARAMS.zoom;
            material.bumpMap = TextureFactory.generate(PARAMS.textureType);
            refreshUI();
            buildGeometries();
            updateScene(true);
        } catch(err) { alert("Invalid JSON file"); }
    };
    reader.readAsText(file);
}

// Buttons
const panel = document.getElementById('controls-panel');
const toggle = document.getElementById('toggle-hud');
const modal = document.getElementById('modal');
const jsonInput = document.getElementById('json-input');

document.getElementById('btn-close').onclick = () => { panel.classList.add('collapsed'); toggle.classList.add('visible'); };
toggle.onclick = () => { panel.classList.remove('collapsed'); toggle.classList.remove('visible'); };
document.getElementById('btn-info').onclick = () => modal.classList.add('visible');
document.getElementById('btn-rand').onclick = randomize;
document.getElementById('btn-reset').onclick = () => { Object.assign(PARAMS, DEFAULTS); refreshUI(); buildGeometries(); updateScene(true); };
document.getElementById('btn-save-img').onclick = () => {
    renderer.render(scene, camera);
    const a = document.createElement('a');
    a.download = 'salty.png';
    a.href = renderer.domElement.toDataURL();
    a.click();
};
document.getElementById('btn-save-json').onclick = exportData;
document.getElementById('btn-load-json').onclick = () => jsonInput.click();
jsonInput.onchange = importData;

window.addEventListener('keydown', e => {
    if(e.key === 'Escape') {
        if(modal.classList.contains('visible')) {
            modal.classList.remove('visible'); // Close modal only
        } else if(!panel.classList.contains('collapsed')) { 
            panel.classList.add('collapsed'); 
            toggle.classList.add('visible'); 
        }
    }
});
modal.onclick = (e) => { if(e.target === modal) modal.classList.remove('visible'); };

window.onload = () => {
    initUI();
    buildGeometries();
    updateScene(true);
    function loop() { requestAnimationFrame(loop); updateCamera(); renderer.render(scene, camera); }
    loop();
    setTimeout(() => document.getElementById('fade-overlay').style.opacity = 0, 500);
};
window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
};
</script>
</body>
</html>